import { useCallback, useEffect, useMemo, useState } from 'react';

import type { Attachment, PvCase, PvChecklistItem, PvExtractedData } from '../types';
import { mockPvCases } from '../mock/casesMock';

const STORAGE_KEY = 'pv_intake_cases_v1';

const createId = () =>
  typeof crypto !== 'undefined' && crypto.randomUUID
    ? crypto.randomUUID()
    : `pv-${Date.now()}-${Math.random().toString(16).slice(2)}`;

const loadCases = (): PvCase[] => {
  if (typeof localStorage === 'undefined') {
    return mockPvCases;
  }

  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (!stored) {
      return mockPvCases;
    }
    const parsed = JSON.parse(stored) as PvCase[];
    return Array.isArray(parsed) && parsed.length > 0 ? parsed : mockPvCases;
  } catch {
    return mockPvCases;
  }
};

const saveCases = (cases: PvCase[]) => {
  if (typeof localStorage === 'undefined') {
    return;
  }
  localStorage.setItem(STORAGE_KEY, JSON.stringify(cases));
};

const mergeExtractedData = (base: PvExtractedData, patch: Partial<PvExtractedData>) => ({
  ...base,
  ...patch,
  pv: {
    ...base.pv,
    ...patch.pv,
  },
  operator: {
    ...base.operator,
    ...patch.operator,
  },
});

const classifyAttachments = (attachments: Attachment[]) => {
  let imageIndex = 0;
  return attachments.map((attachment) => {
    if (attachment.classification) {
      return attachment;
    }
    if (attachment.type !== 'image') {
      return {
        ...attachment,
        classification: 'other',
        extracted: attachment.extracted ?? { fields: {}, confidence: 0.4 },
      };
    }

    const classificationOrder = [
      'meter',
      'inverter_label',
      'battery_label',
      'switchboard',
      'roof',
      'meter_reading',
    ] as const;
    const classification =
      classificationOrder[imageIndex] ?? 'other';
    imageIndex += 1;

    return {
      ...attachment,
      classification,
      extracted: attachment.extracted ?? {
        fields: { hint: classification },
        confidence: 0.72,
      },
    };
  });
};

export const getMissingRequiredItems = (pvCase: PvCase) => {
  const missing: string[] = [];
  const { extractedData, address, messages } = pvCase;
  const inverter = extractedData.pv.inverter;
  const module = extractedData.pv.module;
  const generatorKwp = extractedData.pv.generatorKwp;

  if (!extractedData.operator.name) {
    missing.push('Operator name');
  }
  if (!address) {
    missing.push('Address');
  }
  if (!inverter?.model || !inverter.serialNumber) {
    missing.push('Inverter model + serial');
  }
  if (!generatorKwp && !(module?.count && module.watt)) {
    missing.push('Generator kWp or module count * watt');
  }

  const hasMeterPhoto = messages.some(
    (msg) => msg.classification === 'meter' || msg.classification === 'meter_reading'
  );
  if (!hasMeterPhoto) {
    missing.push('Meter photo');
  }

  return missing;
};

const buildChecklist = (pvCase: PvCase): PvChecklistItem[] => {
  const missing = getMissingRequiredItems(pvCase);
  const requiredItems = missing.map((title) => ({
    id: createId(),
    title,
    done: false,
    severity: 'required' as const,
    autoGenerated: true,
  }));

  return [
    ...requiredItems,
    {
      id: createId(),
      title: 'Review AI extraction summary',
      done: false,
      severity: 'info',
      autoGenerated: true,
    },
  ];
};

export const usePvIntakeStore = () => {
  const [cases, setCases] = useState<PvCase[]>(() => loadCases());
  const [selectedCaseId, setSelectedCaseId] = useState<string | null>(null);
  const [aiRunningIds, setAiRunningIds] = useState<string[]>([]);

  useEffect(() => {
    saveCases(cases);
  }, [cases]);

  useEffect(() => {
    if (!selectedCaseId && cases.length > 0) {
      setSelectedCaseId(cases[0].id);
    }
  }, [cases, selectedCaseId]);

  const selectedCase = useMemo(
    () => cases.find((pvCase) => pvCase.id === selectedCaseId) ?? null,
    [cases, selectedCaseId]
  );

  const createCase = useCallback((data: Partial<PvCase>) => {
    const now = new Date().toISOString();
    const newCase: PvCase = {
      id: createId(),
      createdAt: now,
      updatedAt: now,
      customerName: data.customerName ?? 'New PV Case',
      address: data.address ?? '',
      netzbetreiber: data.netzbetreiber ?? 'stromnetz_berlin',
      status: data.status ?? 'build_done',
      messages: data.messages ?? [],
      extractedData: data.extractedData ?? {
        meterNumber: null,
        pv: { generatorKwp: null, module: null, inverter: null, storage: null },
        operator: { name: null, email: null, phone: null },
      },
      checklist: data.checklist ?? [],
      documents: data.documents ?? {},
    };
    setCases((prev) => [newCase, ...prev]);
    setSelectedCaseId(newCase.id);
    return newCase;
  }, []);

  const updateCase = useCallback((id: string, patch: Partial<PvCase>) => {
    setCases((prev) =>
      prev.map((item) =>
        item.id === id
          ? { ...item, ...patch, updatedAt: new Date().toISOString() }
          : item
      )
    );
  }, []);

  const deleteCase = useCallback((id: string) => {
    setCases((prev) => prev.filter((item) => item.id !== id));
    setSelectedCaseId((prev) => (prev === id ? null : prev));
  }, []);

  const addAttachment = useCallback((caseId: string, attachment: Attachment) => {
    setCases((prev) =>
      prev.map((item) =>
        item.id === caseId
          ? {
              ...item,
              updatedAt: new Date().toISOString(),
              messages: [attachment, ...item.messages],
            }
          : item
      )
    );
  }, []);

  const updateExtractedData = useCallback((caseId: string, patch: Partial<PvExtractedData>) => {
    setCases((prev) =>
      prev.map((item) =>
        item.id === caseId
          ? {
              ...item,
              updatedAt: new Date().toISOString(),
              extractedData: mergeExtractedData(item.extractedData, patch),
            }
          : item
      )
    );
  }, []);

  const toggleChecklistItem = useCallback((caseId: string, itemId: string) => {
    setCases((prev) =>
      prev.map((item) =>
        item.id === caseId
          ? {
              ...item,
              checklist: item.checklist.map((check) =>
                check.id === itemId ? { ...check, done: !check.done } : check
              ),
            }
          : item
      )
    );
  }, []);

  const runAiStructuring = useCallback(async (caseId: string) => {
    setAiRunningIds((prev) => [...prev, caseId]);
    updateCase(caseId, { status: 'ai_structuring' });

    await new Promise((resolve) => setTimeout(resolve, 1200));

    setCases((prev) =>
      prev.map((item) => {
        if (item.id !== caseId) {
          return item;
        }
        const updatedMessages = classifyAttachments(item.messages);
        const existing = item.extractedData;
        const generatorKwp =
          existing.pv.generatorKwp ?? (existing.pv.module ? (existing.pv.module.count * existing.pv.module.watt) / 1000 : 9.6);
        const inverter =
          existing.pv.inverter ?? {
            brand: 'FoxESS',
            model: 'H3-10.0',
            powerKw: 10,
            serialNumber: `FXH3-${Math.floor(Math.random() * 9000 + 1000)}`,
          };
        const storage =
          existing.pv.storage ?? {
            brand: 'FoxESS',
            model: 'ECS2900',
            capacityKwh: 5.8,
            serialNumber: `FXECS-${Math.floor(Math.random() * 9000 + 1000)}`,
          };
        const meterNumber =
          existing.meterNumber ?? `M-${Math.floor(Math.random() * 900000 + 100000)}`;

        const updated: PvCase = {
          ...item,
          updatedAt: new Date().toISOString(),
          status: 'review_missing_data',
          messages: updatedMessages,
          extractedData: {
            ...existing,
            meterNumber,
            pv: {
              ...existing.pv,
              generatorKwp,
              inverter,
              storage,
            },
            operator: {
              ...existing.operator,
              name: existing.operator.name ?? item.customerName,
              email: existing.operator.email ?? null,
              phone: existing.operator.phone ?? null,
            },
          },
        };
        return {
          ...updated,
          checklist: buildChecklist(updated),
        };
      })
    );

    setAiRunningIds((prev) => prev.filter((id) => id !== caseId));
  }, [updateCase]);

  return {
    cases,
    selectedCase,
    selectedCaseId,
    aiRunningIds,
    selectCase: setSelectedCaseId,
    createCase,
    updateCase,
    deleteCase,
    addAttachment,
    updateExtractedData,
    toggleChecklistItem,
    runAiStructuring,
  };
};
